<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>看懂锁！！！ | brilliant-liu</title><meta name="description" content="看懂锁！！！"><meta name="keywords" content="java,锁"><meta name="author" content="brilliant-liu"><meta name="copyright" content="brilliant-liu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="看懂锁！！！"><meta name="twitter:description" content="看懂锁！！！"><meta name="twitter:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2560283127,3256626002&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="看懂锁！！！"><meta property="og:url" content="https://brilliant-liu.github.io/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/"><meta property="og:site_name" content="brilliant-liu"><meta property="og:description" content="看懂锁！！！"><meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2560283127,3256626002&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://brilliant-liu.github.io/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/"><link rel="prev" title="了解JVM" href="https://brilliant-liu.github.io/2020/07/16/%E4%BA%86%E8%A7%A3JVM/"><link rel="next" title="常见面试题汇总" href="https://brilliant-liu.github.io/2020/07/08/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: brilliant-liu","link":"链接: ","source":"来源: brilliant-liu","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 资源清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#锁！"><span class="toc-number">1.</span> <span class="toc-text">锁！</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">1.1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的内存布局"><span class="toc-number">1.2.</span> <span class="toc-text">Java的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关锁的概念"><span class="toc-number">1.3.</span> <span class="toc-text">相关锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#量级划分"><span class="toc-number">1.3.1.</span> <span class="toc-text">量级划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#悲观性划分"><span class="toc-number">1.3.2.</span> <span class="toc-text">悲观性划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平性划分"><span class="toc-number">1.3.3.</span> <span class="toc-text">公平性划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入性划分"><span class="toc-number">1.3.4.</span> <span class="toc-text">重入性划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享性划分"><span class="toc-number">1.3.5.</span> <span class="toc-text">共享性划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥性划分"><span class="toc-number">1.3.6.</span> <span class="toc-text">互斥性划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写性划分"><span class="toc-number">1.3.7.</span> <span class="toc-text">读写性划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的升级过程"><span class="toc-number">1.4.</span> <span class="toc-text">锁的升级过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁消除（lock-eliminate）"><span class="toc-number">1.5.</span> <span class="toc-text">锁消除（lock eliminate）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁粗化（lock-coarsening）"><span class="toc-number">1.6.</span> <span class="toc-text">锁粗化（lock coarsening）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁降级"><span class="toc-number">1.7.</span> <span class="toc-text">锁降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock锁"><span class="toc-number">1.8.</span> <span class="toc-text">Lock锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">1.9.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS原理"><span class="toc-number">1.9.1.</span> <span class="toc-text">AQS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS的核心思想"><span class="toc-number">1.9.2.</span> <span class="toc-text">AQS的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源共享方式"><span class="toc-number">1.9.3.</span> <span class="toc-text">资源共享方式</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2560283127,3256626002&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">brilliant-liu</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 资源清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">看懂锁！！！</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-11 20:36:29"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-11-30 02:53:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-11-30</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="锁！"><a href="#锁！" class="headerlink" title="锁！"></a>锁！</h1><blockquote>
<p>写在前面： </p>
<p>文章内容均来自互联网，加上自己的理解，汇总而成，如若存在错误或者不严谨的地方，还请见谅。文章仅供参考。</p>
<p>特别感谢马士兵老师的视频讲解，特附上学习视频地址： <a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xK4y1C7aT?p=3</a> ，有需要详细了解的可关注马士兵老师。</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS ：Compare and Swap，即比较再交换，也是实现我们平时所说的自旋锁或乐观锁的核心操作。CAS算法实现了区别于synchronouse同步锁的一种乐观锁。下图是CAS的实现原理大致流程</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/07/11/3qJmN2CeOjw96Yx.png"  alt="image.png"></p>
<p>CAS算法理解：CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。通俗的解释是：就是用一个预期的值和内存值进行比较，如果两个值相等，就用预期的值替换内存值，并返回 true。否则，返回 false。</p>
<blockquote>
<p>扩展小细节：</p>
<p><strong>CAS的使用场景：</strong><code>java.util.concurrent</code>包下，比如 CountDownLatch、Semaphore、ReentrantLock 中，再比如 <code>java.util.concurrent.atomic</code> 包下的Atomic* ，比如 AtomicBoolean、AtomicInteger 等。</p>
<p><strong>CAS中的ABA问题：</strong> 其他线程修改数次最后值和原始值相同。解决措施：对原值增加版本号，每次修改更版本号。</p>
<p>CAS操作机制对应的汇编指令：<code>lock cmpxchg</code>，<code>cmpxchg</code>指令是没有原子性的，搭配<code>lock</code>指令在执行的时候会锁定一个北桥信号，从而保证了原子性。</p>
</blockquote>
<h2 id="Java的内存布局"><a href="#Java的内存布局" class="headerlink" title="Java的内存布局"></a>Java的内存布局</h2><p>这里使用的时JVM(HotSpot(TM) 64-Bit)默认开启压缩后的布局及其占用大小。</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/07/11/dIbLDcewyqQU5jn.png"  alt="image.png"></p>
<p>​        通过代码输出查看新建Object的布局信息：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/07/11/Euo39yYkOeBxwWq.png"  alt="image.png"></p>
<blockquote>
<p>扩展：</p>
<ol>
<li><p><code>Object o = new Object()</code>在开启JVM压缩时在内存中占用16个字节，其中markword占用8个，class pointer占用4个，补位4个。未开启压缩时其中markword占用8个，class pointer占用8个，不需要对齐，还是16个。</p>
</li>
<li><p>Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。</p>
</li>
<li><p>查看JVM是否开启压缩：<code>java -XX:+PrintCommandLineFlags -version</code>:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;-XX:InitialHeapSize&#x3D;132425024 -XX:MaxHeapSize&#x3D;2118800384 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">&gt;java version &quot;1.8.0_231&quot;</span><br><span class="line">&gt;Java(TM) SE Runtime Environment (build 1.8.0_231-b11)</span><br><span class="line">&gt;Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)</span><br></pre></td></tr></table></figure>

<p><code>-XX:+UseCompressedClassPointers</code>:压缩指针，默认开启，会把64位的指针8个字节压缩位4个字节。</p>
<p><code>-XX:+UseCompressedOops</code>: 普通对象指针，也会压缩成4个字节</p>
<ol start="3">
<li>查看Java的内存布局方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Test</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testss</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Object o = <span class="keyword">new</span> Object();</span><br><span class="line">   System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="相关锁的概念"><a href="#相关锁的概念" class="headerlink" title="相关锁的概念"></a>相关锁的概念</h2><h3 id="量级划分"><a href="#量级划分" class="headerlink" title="量级划分"></a>量级划分</h3><ol>
<li><p>偏向锁</p>
<p>如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<p>“偏向”的意思是，<em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p>
<p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p>
<blockquote>
<p>偏向锁在Java6和java7里默认是开启的，但是它是应用程序启动几秒之后才会激活，可以通过<code>-XX:BiasedLockingStartuoDelay=0</code>关闭延迟。通过 <code>-XX:-UserBiasedLocking=false</code>关闭偏向锁，那么线程就会默认进入轻量级锁的状态。</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>轻量级锁/自旋锁/自适应自旋锁</p>
<p>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p>
<p>使用轻量级锁时，不需要申请互斥量，仅仅<em>将Mark Word中的部分字节CAS更新指向线程栈中的<code>Lock Record</code>，如果更新成功，则轻量级锁获取成功</em>，记录锁状态为轻量级锁；</p>
<p>如果目前发生了剧烈的线程竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p>
<blockquote>
<p>扩展：</p>
<p>轻量级锁也是指自旋锁，自适应自旋锁，其并没有对资源加锁，只是通过CAS操作，实现对资源的访问控制。因此可以视为无锁</p>
<p>通过<code>-XX:+UseSpinning</code>来开启自旋锁，JDK1.6后默认开启，并引入自适应自旋锁，由JVM控制，一般不需要设置</p>
<p>首先，内核态与用户态的切换上不容易优化。但<strong>通过自旋锁，可以减少线程阻塞造成的线程切换</strong>（包括挂起线程和恢复线程）。</p>
<p>如果锁的粒度小，那么<strong>锁的持有时间比较短</strong>（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：</p>
<ul>
<li>当前线程竞争锁失败时，打算阻塞自己</li>
<li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li>
<li>在自旋的同时重新竞争锁</li>
<li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li>
</ul>
<p>自旋锁的缺点：</p>
<ul>
<li>自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。</li>
<li>如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。</li>
</ul>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p>重量级锁（Synchronized）</p>
<p><code>synchronized</code>是Java提供的一个并发控制的关键字，作用于对象，class，方法块上。</p>
<p>内置锁是JVM提供的最便捷的线程同步工具，在代码块或方法声明上添加synchronized关键字即可使用内置锁。内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p>
<blockquote>
<p>扩展：</p>
<p><code>Synchronized</code>: 独占锁，悲观锁，非公平锁：因为它会无时无刻进行锁住对象，线程之间的切换以及线程从内核态到用户态的时间是耗费性能的。</p>
<p><code>Synchronized</code>: 其保证了代码的原子性和可见性以及有序性，但是不会处理重排序以及代码优化的过程，但是在一个线程中执行肯定是有序的，因此是有序的。</p>
</blockquote>
</li>
</ol>
<h3 id="悲观性划分"><a href="#悲观性划分" class="headerlink" title="悲观性划分"></a>悲观性划分</h3><ol>
<li><p>悲观锁</p>
<p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>
<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>
<blockquote>
<p>扩展</p>
<p><code>Synchronized</code>属于悲观锁</p>
</blockquote>
</li>
<li><p>乐观锁</p>
<p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>
<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式大大的提高了数据操作的性能;</p>
<blockquote>
<p>扩展：</p>
<p>乐观锁： 轻量级锁</p>
</blockquote>
</li>
</ol>
<h3 id="公平性划分"><a href="#公平性划分" class="headerlink" title="公平性划分"></a>公平性划分</h3><ol>
<li><p><strong>公平锁</strong></p>
<p>公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。即公平锁是指多个线程按照申请锁的顺序来获取锁。</p>
</li>
<li><p>非公平锁</p>
<p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>
<blockquote>
<p>非公平锁：Synchronized</p>
</blockquote>
</li>
</ol>
<h3 id="重入性划分"><a href="#重入性划分" class="headerlink" title="重入性划分"></a>重入性划分</h3><ol>
<li><p>可重入锁 </p>
<p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法：同一个线程再次进入同步代码时，可以使用自己已获取到的锁。</p>
</li>
<li><p>不可重入锁</p>
<p>不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。</p>
</li>
</ol>
<h3 id="共享性划分"><a href="#共享性划分" class="headerlink" title="共享性划分"></a>共享性划分</h3><ol>
<li><p>独享锁</p>
<p>是指该锁只能同时被一个线程持有。</p>
<blockquote>
<p><code>ReentrantLock</code>是独享锁</p>
</blockquote>
</li>
<li><p>共享锁</p>
<p>指该锁可以同时被多个线程持有。</p>
<blockquote>
<p><code>ReadWriteLock</code>是一个读的共享锁</p>
</blockquote>
</li>
</ol>
<h3 id="互斥性划分"><a href="#互斥性划分" class="headerlink" title="互斥性划分"></a>互斥性划分</h3><ol>
<li><p>互斥锁</p>
<p>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<p>共享资源的使用是互斥的，即一个线程获得资源的使用权后就会将改资源加锁，使用完后会将其解锁，所以在使用过程中有其它线程想要获取该资源的锁，那么它就会被阻塞陷入睡眠状态，直到该资源被解锁才会别唤醒，如果被阻塞的资源不止一个，那么它们都会被唤醒，但是获得资源使用权的是第一个被唤醒的线程，其它线程又陷入沉睡。</p>
</li>
</ol>
<h3 id="读写性划分"><a href="#读写性划分" class="headerlink" title="读写性划分"></a>读写性划分</h3><ol>
<li><p>读写锁</p>
<p>读写锁拥有读状态加锁、写状态加锁、不加锁三种状态。只有一个线程可以占有写状态的锁，但可以多个线程同时占有读状态锁，这也是它可以实现高并发的原因。</p>
<blockquote>
<p><strong>读写锁三个特征</strong>：</p>
<ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥，只允许一个写者写，也不能读者写者同时进行</li>
<li>写者优先于读者，一旦有写者，则后续读者必须等待，唤醒时优先考虑写者</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="锁的升级过程"><a href="#锁的升级过程" class="headerlink" title="锁的升级过程"></a>锁的升级过程</h2><blockquote>
<p>下面的分析基于64位HotspotJVM</p>
</blockquote>
<p>无锁态（创建对象） –》 偏向锁 –》 轻量级锁 –》 重量级锁</p>
<p>java内存布局中的markword存储锁中信息以及占用的字节大小图：</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/07/11/pSkvwJ9YK3gnyiI.png"  alt="image.png"></p>
<p>​                            （图2）</p>
<blockquote>
<p>图2中部分概念的解释：</p>
<p>分代年龄：新生代 ( Young )、老年代 ( Old ) 通过JVM参数<code>-XX:MaxTenuringThreshold</code> 可以设置,最大为15，占用三个bit。</p>
</blockquote>
<p>锁的升级白话描述：</p>
<ul>
<li><p>无锁（刚创建对象时）到偏向锁</p>
<p>把markword的线程ID改为当前访问线程的ID</p>
<blockquote>
<p>当一个进程T1过来访问资源R时，发现自己时第一个来访问该资源的进程，于是便把该资源锁的markword中的54位记录下当前线程T1的指针<code>javaThread*</code>，同时将偏向锁的锁位由0（无锁状态）改为1（偏向锁状态）。如果该资源R被该线程再次访问，且无其他线程访问过时，则无需加锁，直接允许T1访问。</p>
</blockquote>
</li>
</ul>
<p>​                        </p>
<ul>
<li><p>偏向锁升级到自旋锁</p>
<p>线程在自己的线程栈生成<code>LockRecoder</code>，用CAS操作将markword设置为指向自己线程的<code>LockRecoder</code>的指针，设置成功则获取到锁</p>
<blockquote>
<p>如果存在了多个线程访问资源R，然后立即撤销偏向锁的状态，同时多个线程开始通过CSA机制进行资源R的竞争，先把若线程T1先把线程栈中自己的<code>lock Recoder</code>指针记录到轻量级锁中。则T1获取资源访问权，其他线程只能通过自旋的方式等待访问（<strong>消耗CPU性能</strong>）。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>自旋锁升级到重量级锁</p>
<p>如果线程竞争加剧，将markwork设置指向互斥量<code>mutex</code>重量级锁的指针。</p>
<blockquote>
<p>有线程超过10次自旋（<code>--XX:PreBLockSpin</code>），或者自旋线程数超过CPU核数的一半，JDK1.6后，加入自适应自旋锁（Adaptive Self Spinning），由JVM自己控制是否升级为重量级锁。升级重量级锁后，线程需向操作系统申请资源，并进入无序的等待队列（<strong>线程处于wait状态，不消耗CPU</strong>），等待OS的调度，然后再映射回用户空间。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注意细节：JDK8的对象默认为无锁状态 ，JDK11对象默认为偏向锁。</p>
</blockquote>
<h2 id="锁消除（lock-eliminate）"><a href="#锁消除（lock-eliminate）" class="headerlink" title="锁消除（lock eliminate）"></a>锁消除（lock eliminate）</h2><p>锁消除是发生在编译器级别的一种锁优化方式。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer是线程安全的，因为其关键方法都是被<code>synchronized</code>修饰过的，上面代码中sb只会再add方法内使用，不可能被其他线程引用（局部变量，栈私有），JVM会自动消除StringBuffer对象内部的锁。</p>
<h2 id="锁粗化（lock-coarsening）"><a href="#锁粗化（lock-coarsening）" class="headerlink" title="锁粗化（lock coarsening）"></a>锁粗化（lock coarsening）</h2><p>有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM检测到这样一连串的操作，都会对同一个对象加锁一次，而不是100次加锁，JVM会把锁的范围粗化到这一连串的操作外部，使得一连串的操作只需要加锁一次。</p>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>锁降级发生在GC时，该锁不在被任何 线程访问，没有具体的实际意义了。</p>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>Lock锁提供了的比synchronized关键字更加灵活的锁操作，是代码层面的锁操作。</p>
<p>lock锁和Synchronized锁的比较：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="center">synchronized锁</th>
<th>Lock锁</th>
</tr>
</thead>
<tbody><tr>
<td>获取锁</td>
<td align="center">无超时时间，未获取到则阻塞等待（占用cpu资源），且无法被中断</td>
<td>非阻塞，可以被中断，未获取到则排队，中断，可以自定义超时时间</td>
</tr>
<tr>
<td>共享锁</td>
<td align="center">不支持</td>
<td>读写锁ReadWriteLock支持</td>
</tr>
<tr>
<td>释放锁</td>
<td align="center">synchronized无法获得所得状态，属于自动锁，由当前线程执行完自动释放或者发生异常由JVM自动释放锁</td>
<td>Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</td>
</tr>
<tr>
<td>读写性</td>
<td align="center">synchronized关键字无法读写分离，在多个读线程访问临界资源时，是不需要同步的，但是synchronized关键字通通都给同步了，会导致效率很慢</td>
<td>Lock提供读写锁，实现读写分离；</td>
</tr>
<tr>
<td>中断性</td>
<td align="center">synchronized关键字无法响应中断，如果线程未获得锁，便会一直地尝试去获得锁，不会响应中断</td>
<td>lock锁的lockInterruptibly()方法能让线程响应中断，同时tryLock可以加入时间参数，若一定时间内未获得锁便返回，较为灵活；</td>
</tr>
<tr>
<td>java类型</td>
<td align="center">synchronized是java中的一个关键字，也就是说是Java语言内置的特性。</td>
<td>lock是一个接口是类</td>
</tr>
</tbody></table>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>AQS：AbstractQuenedSynchronizer抽象的队列式同步器。它提供了一种实现阻塞锁和一系列依赖FIFO等待队列（双向链表）的同步器的框架。是除了java自带的synchronized关键字之外的锁机制。</p>
<p>AQS，指的是AbstractQueuedSynchronizer，，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p>
<h3 id="AQS的核心思想"><a href="#AQS的核心思想" class="headerlink" title="AQS的核心思想"></a>AQS的核心思想</h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。</p>
<p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p>
</blockquote>
<p>获取锁的流程：</p>
<p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/11772136-630de1626ef407e1.png"  alt="AQS流程"></p>
<h3 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h3><p>AQS 定义了两种资源共享方式：</p>
<ul>
<li><p><strong>Exclusive</strong></p>
<p>独占，只有一个线程能执行，如ReentrantLock</p>
</li>
<li><p><strong>Share</strong></p>
<p>共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">brilliant-liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://brilliant-liu.github.io/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/">https://brilliant-liu.github.io/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://brilliant-liu.github.io" target="_blank">brilliant-liu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-94a00bfec307801902f81d81140a1c8a_1200x500.jpg&amp;refer=http%3A%2F%2Fpic2.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/16/%E4%BA%86%E8%A7%A3JVM/"><img class="prev_cover lazyload" data-src="https://upload-images.jianshu.io/upload_images/5401760-cde4aefdad5438ca.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">了解JVM</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/08/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><img class="next_cover lazyload" data-src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495300491,4227073467&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见面试题汇总</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/16/lambda表达式详解/" title="lambda表达式详解"><img class="relatedPosts_cover lazyload"data-src="https://www.linuxidc.com/upload/2014-09/140905163467611.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-16</div><div class="relatedPosts_title">lambda表达式详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/30/什么是跨域/" title="什么是跨域"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-30</div><div class="relatedPosts_title">什么是跨域</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/15/关于java序列化/" title="关于java序列化"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2020/05/15/FqC2jtznbeHglaO.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-15</div><div class="relatedPosts_title">关于java序列化</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/16/设计模式-建造者模式/" title="设计模式-建造者模式"><img class="relatedPosts_cover lazyload"data-src="http://boolan.com/UploadResources/PreviewImages/Course/4bfeed07-bbe1-43cc-9ae9-0293f9484e39.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-16</div><div class="relatedPosts_title">设计模式-建造者模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/24/设计模式-观察者模式/" title="设计模式-观察者模式"><img class="relatedPosts_cover lazyload"data-src="http://boolan.com/UploadResources/PreviewImages/Course/4bfeed07-bbe1-43cc-9ae9-0293f9484e39.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-24</div><div class="relatedPosts_title">设计模式-观察者模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/24/设计模式-适配器模式/" title="设计模式-适配器模式"><img class="relatedPosts_cover lazyload"data-src="http://boolan.com/UploadResources/PreviewImages/Course/4bfeed07-bbe1-43cc-9ae9-0293f9484e39.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-24</div><div class="relatedPosts_title">设计模式-适配器模式</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2560283127,3256626002&amp;fm=26&amp;gp=0.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By brilliant-liu</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">让我们从现在开始，把每一刻都过的值得。</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>