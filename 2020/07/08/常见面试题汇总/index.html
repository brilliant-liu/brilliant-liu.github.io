<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常见面试题汇总 | brilliant-liu</title><meta name="description" content="常见面试题汇总"><meta name="keywords" content="面试"><meta name="author" content="brilliant-liu"><meta name="copyright" content="brilliant-liu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="常见面试题汇总"><meta name="twitter:description" content="常见面试题汇总"><meta name="twitter:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495300491,4227073467&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="常见面试题汇总"><meta property="og:url" content="https://brilliant-liu.github.io/2020/07/08/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><meta property="og:site_name" content="brilliant-liu"><meta property="og:description" content="常见面试题汇总"><meta property="og:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495300491,4227073467&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://brilliant-liu.github.io/2020/07/08/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><link rel="prev" title="看懂锁！！！" href="https://brilliant-liu.github.io/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/"><link rel="next" title="docker安装ElasticSearch" href="https://brilliant-liu.github.io/2020/07/05/docker%E5%AE%89%E8%A3%85ElasticSearch/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: brilliant-liu","link":"链接: ","source":"来源: brilliant-liu","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 资源清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring相关"><span class="toc-number">1.</span> <span class="toc-text">Spring相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Springbean的作用域"><span class="toc-number">1.1.</span> <span class="toc-text">Springbean的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#各个作用域的详解"><span class="toc-number">1.1.1.</span> <span class="toc-text">各个作用域的详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用这些作用域"><span class="toc-number">1.1.2.</span> <span class="toc-text">如何使用这些作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext担任什么样的角色"><span class="toc-number">1.1.3.</span> <span class="toc-text">ApplicationContext担任什么样的角色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务与隔离"><span class="toc-number">1.2.</span> <span class="toc-text">事务与隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#脏读、不可重复度、幻读"><span class="toc-number">1.2.1.</span> <span class="toc-text">脏读、不可重复度、幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的特性"><span class="toc-number">1.2.2.</span> <span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql中的事务隔离级别"><span class="toc-number">1.2.3.</span> <span class="toc-text">Mysql中的事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring的事务隔离级别"><span class="toc-number">1.2.4.</span> <span class="toc-text">spring的事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring事务的传播方式"><span class="toc-number">1.2.5.</span> <span class="toc-text">spring事务的传播方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring事务的配置方式"><span class="toc-number">1.2.6.</span> <span class="toc-text">Spring事务的配置方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务管理器"><span class="toc-number">1.2.7.</span> <span class="toc-text">事务管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事务的基本属性"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">事务的基本属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring中传播行为"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">spring中传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务超时"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">事务超时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring框架中bean的生命周期"><span class="toc-number">1.3.</span> <span class="toc-text">Spring框架中bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired和-Resource的区别"><span class="toc-number">1.4.</span> <span class="toc-text">@Autowired和@Resource的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring自动装配的模式"><span class="toc-number">1.5.</span> <span class="toc-text">spring自动装配的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#servlet的生命周期"><span class="toc-number">1.6.</span> <span class="toc-text">servlet的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring两大特性"><span class="toc-number">1.7.</span> <span class="toc-text">spring两大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC"><span class="toc-number">1.8.</span> <span class="toc-text">SpringMVC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MYSQL"><span class="toc-number">2.</span> <span class="toc-text">MYSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#索引查询失效"><span class="toc-number">2.1.</span> <span class="toc-text">索引查询失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql优化"><span class="toc-number">2.2.</span> <span class="toc-text">Mysql优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">2.3.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">2.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis的二级缓存（自定义）"><span class="toc-number">3.</span> <span class="toc-text">mybatis的二级缓存（自定义）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-number">4.1.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM中默认的类加载器"><span class="toc-number">4.1.1.</span> <span class="toc-text">JVM中默认的类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载的过程"><span class="toc-number">4.1.2.</span> <span class="toc-text">类加载的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派模式"><span class="toc-number">4.1.3.</span> <span class="toc-text">双亲委派模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized锁升级"><span class="toc-number">4.2.</span> <span class="toc-text">synchronized锁升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机指令重排的有哪些规则"><span class="toc-number">4.3.</span> <span class="toc-text">虚拟机指令重排的有哪些规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令重排"><span class="toc-number">4.4.</span> <span class="toc-text">指令重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重排规则"><span class="toc-number">4.5.</span> <span class="toc-text">重排规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile的用法"><span class="toc-number">4.6.</span> <span class="toc-text">volatile的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存屏障"><span class="toc-number">4.7.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存屏障的作用"><span class="toc-number">4.8.</span> <span class="toc-text">内存屏障的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java中的内存屏障"><span class="toc-number">4.9.</span> <span class="toc-text">java中的内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile中的内存屏障"><span class="toc-number">4.10.</span> <span class="toc-text">volatile中的内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程栈有可能发生哪些异常（内存溢出）"><span class="toc-number">4.11.</span> <span class="toc-text">线程栈有可能发生哪些异常（内存溢出）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oom排查"><span class="toc-number">4.12.</span> <span class="toc-text">oom排查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis为什么这么快"><span class="toc-number">5.</span> <span class="toc-text">redis为什么这么快</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存穿透、缓存击穿、缓存雪崩、缓存预热"><span class="toc-number">6.</span> <span class="toc-text">缓存穿透、缓存击穿、缓存雪崩、缓存预热</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单例"><span class="toc-number">7.</span> <span class="toc-text">单例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DCL单例（Double-Check-Lock）"><span class="toc-number">7.1.</span> <span class="toc-text">DCL单例（Double Check Lock）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统底层如何实现数据一致性"><span class="toc-number">8.</span> <span class="toc-text">系统底层如何实现数据一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存一致性协议："><span class="toc-number">8.1.</span> <span class="toc-text">缓存一致性协议：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程和线程的区别"><span class="toc-number">9.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#消息中间件MQ的对比"><span class="toc-number">10.</span> <span class="toc-text">消息中间件MQ的对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何保障redis的高可用"><span class="toc-number">11.</span> <span class="toc-text">如何保障redis的高可用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Zookeeper"><span class="toc-number">12.</span> <span class="toc-text">Zookeeper</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495300491,4227073467&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">brilliant-liu</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 资源清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">常见面试题汇总</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-08 18:43:33"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-08</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-11-30 02:53:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-11-30</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Spring相关"><a href="#Spring相关" class="headerlink" title="Spring相关"></a>Spring相关</h1><h2 id="Springbean的作用域"><a href="#Springbean的作用域" class="headerlink" title="Springbean的作用域"></a>Springbean的作用域</h2><table>
<thead>
<tr>
<th>作用域</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td align="left">在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</td>
</tr>
<tr>
<td>prototype</td>
<td align="left">每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td>
</tr>
<tr>
<td>request</td>
<td align="left">每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</td>
</tr>
<tr>
<td>session</td>
<td align="left">同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的SpringWebApplicationContext环境。</td>
</tr>
<tr>
<td>application</td>
<td align="left">限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</td>
</tr>
</tbody></table>
<h3 id="各个作用域的详解"><a href="#各个作用域的详解" class="headerlink" title="各个作用域的详解"></a>各个作用域的详解</h3><ul>
<li><p>singleton</p>
<p>如果bean的作用域的属性被声明为<strong>singleton(单例类型)</strong>那么Spring Ioc容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。</p>
</li>
<li><p>prototype</p>
<p>当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。</p>
</li>
<li><p>request</p>
<p>当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。</p>
</li>
<li><p>session</p>
<p>Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。</p>
</li>
<li><p>application</p>
<p>application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。</p>
<p>application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见</p>
</li>
</ul>
<h3 id="如何使用这些作用域"><a href="#如何使用这些作用域" class="headerlink" title="如何使用这些作用域"></a>如何使用这些作用域</h3><blockquote>
<p>@Component()注解是告诉Spring这是一个bean。<br>@Scope(“prototype”) 注解是告诉Spring该bean的作用域是prototype。</p>
</blockquote>
<h3 id="ApplicationContext担任什么样的角色"><a href="#ApplicationContext担任什么样的角色" class="headerlink" title="ApplicationContext担任什么样的角色"></a>ApplicationContext担任什么样的角色</h3><p>​    ApplicationContext是一个接口，的中文意思是“应用前后关系”，它主要继承自BeanFactory接口，除了包含BeanFactory的所有功能之外，在国际化支持、资源访问（如URL和文件）、事件传播等方面进行了良好的支持，可应用在Java APP与Java Web中。</p>
<p>​    在其中的众多实现者中，最主要且常见的有<code>AnnotationConfigApplicationContext</code>、<code>ClassPathXmlApplicationContext</code>、<code>XmlWebApplicationContext</code>等，这些实现类的主要区别就是装载Spring配置文件实例化ApplicationContext容器的方式不同，在ApplicationContext实例化后，同样通过getBean方法从ApplicationContext容器中获取装配好的Bean实例以供使用。</p>
<h2 id="事务与隔离"><a href="#事务与隔离" class="headerlink" title="事务与隔离"></a>事务与隔离</h2><h3 id="脏读、不可重复度、幻读"><a href="#脏读、不可重复度、幻读" class="headerlink" title="脏读、不可重复度、幻读"></a>脏读、不可重复度、幻读</h3><p>脏读 ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。</p>
<p> 幻读 : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</p>
<blockquote>
<p>不可重复读的重点是修改 :<br>同样的条件 ,  你读取过的数据 ,  再次读取出来发现值不一样了<br>幻读的重点在于新增或者删除<br>同样的条件 ,  第 1 次和第 2 次读出来的记录数不一样</p>
</blockquote>
<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul>
<li>原子性 （atomicity）:强调事务的不可分割.</li>
<li>一致性 （consistency）:事务的执行的前后数据的完整性保持一致.</li>
<li>隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰</li>
<li>持久性（durability） :事务一旦结束,数据就持久到数据库</li>
</ul>
<h3 id="Mysql中的事务隔离级别"><a href="#Mysql中的事务隔离级别" class="headerlink" title="Mysql中的事务隔离级别"></a>Mysql中的事务隔离级别</h3><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read Uncommitted</td>
<td align="left">读未提交，顾名思义，就是可以读到未提交的内容。会引起脏读</td>
</tr>
<tr>
<td align="left">Read Committed</td>
<td align="left">读提交，顾名思义，就是只能读到已经提交了的内容。</td>
</tr>
<tr>
<td align="left">Repeated Read</td>
<td align="left">REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的。</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left">SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，因此性能会比较低下。</td>
</tr>
</tbody></table>
<blockquote>
<p>扩展：</p>
<ul>
<li><p>innodb的默认事务隔离级别是rr（可重复读）</p>
<p>在这个级别下，普通的查询同样是使用的快照读(snapshot read)</p>
</li>
<li><p>快照读，它的实现技术是mvcc，基于版本的控制协议。</p>
</li>
</ul>
</blockquote>
<h3 id="spring的事务隔离级别"><a href="#spring的事务隔离级别" class="headerlink" title="spring的事务隔离级别"></a>spring的事务隔离级别</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>这是默认值，表示使用底层数据库的默认隔离级别</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以<strong>防止脏读</strong>，这也是大多数情况下的推荐值。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以<strong>防止脏读和不可重复读</strong>。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。</td>
</tr>
</tbody></table>
<blockquote>
<p>spring的事务隔离级别其实本质上是对SQL标准的4种事务隔离级别的一种封装。</p>
</blockquote>
<h3 id="spring事务的传播方式"><a href="#spring事务的传播方式" class="headerlink" title="spring事务的传播方式"></a>spring事务的传播方式</h3><table>
<thead>
<tr>
<th>传播方式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式运行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</td>
</tr>
</tbody></table>
<blockquote>
<p>扩展：</p>
<p>propagation ：  [ˌprɒpə’ɡeɪʃ(ə)n] 传播</p>
</blockquote>
<h3 id="Spring事务的配置方式"><a href="#Spring事务的配置方式" class="headerlink" title="Spring事务的配置方式"></a>Spring事务的配置方式</h3><p>spring支持编程式事务管理和声明式事务管理两种方式：</p>
<ul>
<li><p>编程式事务管理</p>
<p>在xml配置注入TransactionTemplate的bean，在service服务代码调用TransactionTemplate。</p>
</li>
<li><p>声明式事务管理建立在AOP之上的。</p>
<p>在 xml配置aop切面，核心事务管理器：transactionManager，其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
</li>
<li><p>注解配置aop</p>
<p>开启注解管理事务。导入约束：transactionManager。</p>
</li>
</ul>
<h3 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h3><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。<br>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/02/VgnKsySCHqDP6Fz.png"  alt="image.png"></p>
<p><a href="https://img-blog.csdn.net/20160324011156424" target="_blank" rel="noopener">备用图片地址</a></p>
<p>从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。</p>
<blockquote>
<p>扩展：</p>
<p>JDBC事务管理器：</p>
<p><code>DataSourceTransactionManager</code>是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
</blockquote>
<h4 id="事务的基本属性"><a href="#事务的基本属性" class="headerlink" title="事务的基本属性"></a>事务的基本属性</h4><ul>
<li>事务的传播行为</li>
<li>事务的隔离级别</li>
<li>事务的回滚规则</li>
<li>事务超时</li>
<li>是否只读</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/02/UHYkteu8ihI69N5.png"  alt="image.png"></p>
<p><a href="https://img-blog.csdn.net/20160325003448793" target="_blank" rel="noopener">备用图片地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务的主要行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="spring中传播行为"><a href="#spring中传播行为" class="headerlink" title="spring中传播行为"></a>spring中传播行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA&#123;</span><br><span class="line">    ……</span><br><span class="line">    methodB();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodB&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用MethodA时，环境中没有事务，所以开启一个新的事务.当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">  methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_SUPPORTS</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_MANDATORY</span></span><br><span class="line">    methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRES_NEW</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里，我把调用方法A的事务称称为外层事务ts1，methodB的事务称为内层事务ts2。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于 ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了 methodB之外的其它代码导致的结果却被回滚了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：</p>
<p>使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_NESTED</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////上面的代码等价于 ////////////////////</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line">    Savepoint savepoint = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        con = getConnection();</span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        doSomeThingA();</span><br><span class="line">        savepoint = con2.setSavepoint();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            methodB();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RuntimeException ex) &#123;</span><br><span class="line">            con.rollback(savepoint);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        doSomeThingB();</span><br><span class="line">        con.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RuntimeException ex) &#123;</span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套事务一个非常重要的概念就是 内层事务依赖于外层事务。</span></span><br><span class="line"><span class="comment">// 外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>PROPAGATION_NESTED</code> 与<code>PROPAGATION_REQUIRES_NEW</code>的区别</p>
<ul>
<li>都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。</li>
<li>PROPAGATION_REQUIRES_NEW的内外两个事务相互独立，互不影响。</li>
<li>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚。</li>
</ul>
</blockquote>
<h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，<strong>在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束</strong>。</p>
<h2 id="Spring框架中bean的生命周期"><a href="#Spring框架中bean的生命周期" class="headerlink" title="Spring框架中bean的生命周期"></a>Spring框架中bean的生命周期</h2><p>1.首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，</p>
<p>2.按照Bean定义信息配置信息，注入所有的属性，</p>
<p>3.如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，</p>
<p>4.如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，</p>
<p>5.如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，</p>
<p>6.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，</p>
<p>7.如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，</p>
<p>8.如果Bean配置了init-method方法，则会执行init-method配置的方法，</p>
<p>9.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，</p>
<p>10.经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了</p>
<p>11.容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，</p>
<p>12.如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束。</p>
<blockquote>
<p>思考如何简化描述该流程？</p>
</blockquote>
<h2 id="Autowired和-Resource的区别"><a href="#Autowired和-Resource的区别" class="headerlink" title="@Autowired和@Resource的区别"></a>@Autowired和@Resource的区别</h2><table>
<thead>
<tr>
<th>区别项</th>
<th>@Resource</th>
<th>@AutoWired</th>
</tr>
</thead>
<tbody><tr>
<td>提供方</td>
<td>由javax.annotation.Resource提供，即J2EE提供，需要JDK1.6及以上。</td>
<td>org.springframework.beans.factory.annotation.Autowired提供，换句话说就是由Spring提供</td>
</tr>
<tr>
<td>注入方式</td>
<td>标注在字段或属性的setter方法上，但它默认按名称装配，也可按照类型装配。注入bean的对象名默认取属性名。</td>
<td>@Autowired只按照类型注入</td>
</tr>
<tr>
<td>注入效果</td>
<td>@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，默认取字段的名称作为bean名称</td>
<td>默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false；想使用按名称装配，可以结合@Qualifier注解一起使用。</td>
</tr>
<tr>
<td>异常</td>
<td>注入对象找不到唯一的匹配的，则抛出异常</td>
<td>可以注入null值（设置它required属性为false）</td>
</tr>
</tbody></table>
<h2 id="spring自动装配的模式"><a href="#spring自动装配的模式" class="headerlink" title="spring自动装配的模式"></a>spring自动装配的模式</h2><p>自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入：</p>
<ul>
<li><p>no</p>
<p>默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。</p>
</li>
<li><p>byName</p>
<p>通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</p>
</li>
<li><p>byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。如果有多个bean符合条件，则抛出错误。</p>
</li>
<li><p>constructor</p>
<p>这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。</p>
</li>
<li><p>autodetect</p>
<p>如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
<blockquote>
<p>扩展：</p>
<p>@Autowired只支持按照byType注入方式，@Resource支持byName和byType注入，默认byName注入。</p>
</blockquote>
</li>
</ul>
<h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h2><ul>
<li><p>加载和实例化</p>
<p>当客户端向 Servlet 容器发出 HTTP 请求要求访问 Servlet 时，Servlet 容器首先会解析请求，检查内存中是否已经有了该 Servlet 对象，如果有，则直接使用该 Servlet 对象，如果没有，则创建 Servlet 实例对象，然后通过调用 init() 方法实现 Servlet 的初始化工作。需要注意的是，在 Servlet 的整个生命周期内，它的 init() 方法只能被调用一次。</p>
</li>
<li><p>执行接端（处理客户端请求）</p>
<p>Servlet 容器会为这个请求创建代表 HTTP 请求的 ServletRequest 对象和代表 HTTP 响应的 ServletResponse 对象，然后将它们作为参数传递给 Servlet 的 service() 方法。</p>
<p>service() 方法从 ServletRequest 对象中获得客户请求信息并处理该请求，通过 ServletResponse 对象生成响应结果。</p>
</li>
<li><p>销毁阶段</p>
<p>当服务器关闭或 Web 应用被移除出容器时，Servlet 随着 Web 应用的关闭而销毁。在销毁 Servlet 之前，Servlet 容器会调用 Servlet 的 destroy() 方法，以便让 Servlet 对象释放它所占用的资源。在 Servlet 的整个生命周期中，destroy() 方法也只能被调用一次。</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/01/3ByPVtjWaKTLkXb.png"  alt="image.png"></p>
<h2 id="spring两大特性"><a href="#spring两大特性" class="headerlink" title="spring两大特性"></a>spring两大特性</h2><ul>
<li><p>IOC：IOC，另外一种说法叫DI（Dependency Injection），即依赖注入。IOC并不是一种技术实现，而是一种设计思想。Spring通过IOC实现了松散耦合，SpringIOC负责创建对象，管理对象，通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
</li>
<li><blockquote>
<p>扩展：</p>
<p>DI: 是IOC的一个方面，是个通常的概念，你不需要在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后由容器（IOC容器）负责把他们组装起来。</p>
</blockquote>
</li>
<li><p>AOP（Aspect-OrientedProgramming），即“面向切面编程，是一种编程技术，允许程序<br>模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p>
<blockquote>
<p>扩展：</p>
<ul>
<li><p>Aspect切面(aspect)<br>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。切面通过带有@Aspect注解的类实现。</p>
</li>
<li><p>关注点和横切关注的区别是什么？<br>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
</li>
<li><p>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
</li>
<li><p>连接点(joinpoint)<br>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行SpringAOP的位置。</p>
</li>
<li><p>通知（advice）<br>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。<br>Spring切面可以应用五种类型的通知：</p>
<ul>
<li>before：前置通知，在一个方法执行前被调用。</li>
<li>after:在方法执行之后调用的通知，无论方法执行是否成功。</li>
<li>after-returning:仅当方法成功完成后执行的通知。</li>
<li>after-throwing:在方法抛出异常退出时执行的通知。</li>
<li>around:在方法执行之前和之后调用的通知。</li>
</ul>
</li>
<li><p>切点(joincut)</p>
<p>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>如何自己实现一个AOP：</p>
<ol>
<li>首先要弄清自己的关注点，我们要实现什么功能。</li>
<li>其次理清自己的通知类型，是前置通知，还是后置通知等。</li>
<li>定义一个注解，并使用该注解作为连接点。</li>
<li>定义一个切面类，并指明切入点，绑定具体的通知类型，实现自己应该有的业务逻辑。</li>
</ol>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/01/NmkC64ige7fxhOX.png"  alt="image.png"></p>
<p><a href="https://img-blog.csdn.net/20180708224853769" target="_blank" rel="noopener">备用图片地址连接</a></p>
<p>流程描述：</p>
<ul>
<li>用户发送请求至前端控制器DispatcherServlet；</li>
<li>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li>
<li>DispatcherServlet 调用 HandlerAdapter处理器适配器；</li>
<li>HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；</li>
<li>Handler执行完成返回ModelAndView；</li>
<li>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li>
<li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</li>
<li>ViewResolver解析后返回具体View；</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户。</li>
</ul>
<blockquote>
<p>流程简化：</p>
<p>一查找，二给适配器执行，三进行视图解析，四视图渲染，五返回给用户</p>
<p>用户发起请求，DispatcherServlet根据请求request到handlerMapping中查找负责执行的handler，并将拿到的handler通过HandlerAdapt适配器进行方法的调用，然后将返回的modelAndView交给视图解析器进行视图解析，然后将返回视图对象交给的view进行渲染，并返回给用户。</p>
</blockquote>
<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="索引查询失效"><a href="#索引查询失效" class="headerlink" title="索引查询失效"></a>索引查询失效</h2><ul>
<li><p>like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。</p>
</li>
<li><p>or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</p>
</li>
<li><p>组合索引，不是使用第一列索引，索引失效。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</p>
</li>
<li><p>不等于(！= ，&lt;&gt; )，EXISTS，not in,is  not null,&gt;,&lt;都会失效，in（in里面包含了子查询）（非主键索引）</p>
<blockquote>
<p>优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>可以使用explain命令加在要分析的sql语句前面，在执行结果中查看key这一列的值，如果为NULL，说明没有使用索引。</p>
</blockquote>
<h2 id="Mysql优化"><a href="#Mysql优化" class="headerlink" title="Mysql优化"></a>Mysql优化</h2><ul>
<li><p>为搜索字段建索引</p>
</li>
<li><p>当只要一行数据时使用 LIMIT 1<br>MySQL 数据库引擎<br>会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。其效率更高。</p>
</li>
<li><p>在 Join 表的时候使用相当类型的例，并将其索引<br>这些被用来 Join 的字段，应该是相同的类型的。例如：如果你要把<br>DECIMAL 字段和一个 INT 字段 Join 在一起，MySQL 就无法使用它们的索引。</p>
</li>
<li><p>永远为每张表设置一个 ID<br>我们应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一<br>个 INT 型的(推荐使用 UNSIGNED)，并设置上自动增加的 AUTO_INCREMENT 标<br>志。<br>使用 VARCHAR 类型来当主键会使用得性能下降。</p>
</li>
<li><p>使用 ENUM 而不是 VARCHAR</p>
<p>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p>
<p>如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或 “部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM而不是 VARCHAR</p>
</li>
<li><p>尽可能的使用 NOT NULL</p>
</li>
<li><p>把 IP 地址存成 UNSIGNED INT</p>
<p>很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的 IP 而不是</p>
<p>整形的 IP。如果你用整形来存放，只需要 4 个字节，并且你可以有定长的字</p>
<p>段。我们必需要使用 UNSIGNED INT，因为 IP 地址会使用整个 32 位的无符号整</p>
<p>形。</p>
<p>而你的查询，你可以使用 INET_ATON() 来把一个字符串 IP 转成一个整形，</p>
<p>并使用 INET_NTOA() 把一个整形转成一个字符串 IP。</p>
</li>
<li><p>固定长度的表会更快</p>
<p>固定长度的表会提高性能，因为 MySQL 搜寻得会更快一些，因为这些固定</p>
<p>的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如</p>
<p>果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p>
<blockquote>
<p>固定长度的表中，表中没有如下类型的字段： VARCHAR，TEXT，</p>
<p>BLOB。</p>
</blockquote>
</li>
<li><p>垂直分割</p>
<p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降</p>
<p>低表的复杂度和字段的数目，从而达到优化的目的。</p>
</li>
<li><p>拆分大的 DELETE 或 INSERT 语句</p>
<p>因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p>
<blockquote>
<p>解决方案： 如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是</p>
<p>一个好的方法。每次删除后，都睡眠一会，在操作。</p>
</blockquote>
</li>
<li><p>关于查询缓存<br>MySQL 的查询缓存对这个函数<br>不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的 SQL 函数都不会开<br>启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是<br>用一个变量来代替 MySQL 的函数，从而开启缓存。</p>
</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>Mysql中的MVCC，英文全称为Multi-Version Concurrency Control，翻译为中文即 多版本并发控制。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广</p>
</li>
<li><p>MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/02/CXT8IRpFgB63r1o.png"  alt="image.png"></p>
<p><a href="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1MzYyODkwMzA5MDRjMGRmMzFkYjM2?x-oss-process=image/format,png" target="_blank" rel="noopener">备用图片地址</a></p>
<p>上图解释：</p>
<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本。</li>
<li>修改时Copy出当前版本随意修改，各个事务之间无干扰。</li>
<li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li>
</ul>
<blockquote>
<p>扩展</p>
<p>MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。</p>
<p>Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.。</p>
<p>串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。</p>
</blockquote>
<h1 id="mybatis的二级缓存（自定义）"><a href="#mybatis的二级缓存（自定义）" class="headerlink" title="mybatis的二级缓存（自定义）"></a>mybatis的二级缓存（自定义）</h1><p>详情见我的博客： <a href="">Mybatis</a></p>
<p>@Cacheable可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>Java源代码.java文件通过编译成字节码.class文件后，需要被加载到Java虚拟机的内存空间中使用，这个过程就是类加载。类加载依靠的是Java类加载器</li>
<li>Java类加载器是Java运行时环境的一部分，负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载的，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件的位置与文件系统。</li>
</ul>
<h3 id="JVM中默认的类加载器"><a href="#JVM中默认的类加载器" class="headerlink" title="JVM中默认的类加载器"></a>JVM中默认的类加载器</h3><ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong></p>
<p>负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）</p>
</li>
<li><p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<p>负责加载java平台中扩展功能的一些jar包，包括JDK/jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p>
</li>
<li><p><strong>应用程序类加载器（Application ClassLoader）</strong></p>
<p>负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
<li><p><strong>自定义类加载器 Custom ClassLoader</strong></p>
<p>通过继承java.lang.ClassLoader根据自身需要自定义ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。</p>
</li>
</ul>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/01/Hsw5KNriM4OIBv8.png"  alt="image.png"></p>
<ul>
<li><p>加载</p>
<p>类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象</p>
</li>
<li><p>验证</p>
<p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
</li>
<li><p>准备</p>
<p>为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
</li>
<li><p>解析</p>
<p>主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用。</p>
</li>
<li><p>初始化</p>
<p>类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。</p>
</li>
</ul>
<p>这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。</p>
<blockquote>
<p>扩展：</p>
<p>类加载顺序示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liukj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/8/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： 类加载的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"9"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造代码块</span></span><br><span class="line"><span class="comment">     * 作用是给对象进行初始化。构造代码块中定义的是不同对象共性的初始化内容，优先于构造函数执行。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 对象一建立就运行构造代码块了，而且优先于构造函数执行。</span></span><br><span class="line"><span class="comment">     * 2. 构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。</span></span><br><span class="line"><span class="comment">     *    因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。</span></span><br><span class="line"><span class="comment">     *    也就是说，构造代码块中定义的是不同对象共性的初始化内容。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"&#123;&#125; = 开始============"</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">"&#123;&#125; = 结束============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它是随着类的加载而执行，只执行一次，并优先于主函数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static = 开始============"</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(<span class="string">"static = 结束============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassLoader()&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始执行构造方法=========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行 instanceMethods .............."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> ClassLoader();</span><br><span class="line">        classLoader.instanceMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> = 开始============</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">static</span> = 结束============</span><br><span class="line">&#123;&#125; = 开始============</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&#123;&#125; = 结束============</span><br><span class="line">开始执行构造方法==========</span><br><span class="line">执行 instanceMethods ..............</span><br></pre></td></tr></table></figure>



<p>单例模式下的加载顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> icop.test.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: liukj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/8/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： 类加载的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意这里再内部初始了一下自己,且其是静态的，所以类加载的时候会首先处理它，</span></span><br><span class="line"><span class="comment">     * 即创建一个对象（这里只会处理实例变量，构造代码块和构造方法）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num1 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClassLoader classLoader = <span class="keyword">new</span> ClassLoader();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意num1和num2的区别</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里是静态变量，会按照初始化的顺序加载，所以上面对象创建时，这里还没有被加载，会默认为0;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String  obj = <span class="keyword">new</span> String (<span class="string">"1023"</span>);</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"9"</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"&#123;&#125; = 开始============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"num1:"</span>+num1);</span><br><span class="line">        System.out.println(<span class="string">"num2:"</span>+num2);</span><br><span class="line">        System.out.println(<span class="string">"str:"</span>+str);</span><br><span class="line">        System.out.println(<span class="string">"obj:"</span>+obj);</span><br><span class="line">        System.out.println(<span class="string">"&#123;&#125; = 结束============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它是随着类的加载而执行，只执行一次，并优先于主函数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"static = 开始============"</span>);</span><br><span class="line">        System.out.println(<span class="string">"num1:"</span>+num1);</span><br><span class="line">        System.out.println(<span class="string">"num2:"</span>+num2);</span><br><span class="line">        System.out.println(<span class="string">"obj:"</span>+obj);</span><br><span class="line">        System.out.println(<span class="string">"static = 结束============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始执行构造方法=========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行 instanceMethods .............."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader.getInstance().instanceMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; &#x3D; 开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">num1:5</span><br><span class="line">num2:0</span><br><span class="line">str:9</span><br><span class="line">obj:null</span><br><span class="line">&#123;&#125; &#x3D; 结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">开始执行构造方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">static &#x3D; 开始&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">num1:5</span><br><span class="line">num2:5</span><br><span class="line">obj:1023</span><br><span class="line">static &#x3D; 结束&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">执行 instanceMethods ..............</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>工作原理：</p>
<p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p>
<p>优势：</p>
<ul>
<li>通过这种层级关可以避免类的重复加载</li>
<li>其次是考虑到安全因素，java核心api中定义类型不会被随意替换</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/08/01/ImBlpTb6rc4xihM.png"  alt="image.png"></p>
<blockquote>
<p>扩展：</p>
<p>在JVM中表示两个class对象是否为同一个类对象存在两个必要条件</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</li>
</ul>
<p>实现自定义类加载器需要继承ClassLoader或者URLClassLoader，继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑，继承URLClassLoader则可以省去编写findClass()方法以及class文件加载转换成字节码流的代码。</p>
</blockquote>
<h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2><p>详见本人博客： <a href="[https://brilliant-liu.github.io/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/#%E9%94%81%EF%BC%81](https://brilliant-liu.github.io/2020/07/11/看懂锁！！！/#锁！)">brilliant-liu</a></p>
<p>synchronized底层实现过程：</p>
<ol>
<li>代码层增加synchronized关键字</li>
<li>使用monitorenter moniterexit监视进入和退出锁的状态</li>
<li>在jvm执行的时候，进行锁的自动升级</li>
<li>在到达重量级锁时，底层使用 <code>lock comxchg</code>指令进行并发控制。</li>
<li></li>
</ol>
<h2 id="虚拟机指令重排的有哪些规则"><a href="#虚拟机指令重排的有哪些规则" class="headerlink" title="虚拟机指令重排的有哪些规则"></a>虚拟机指令重排的有哪些规则</h2><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。</p>
<h2 id="重排规则"><a href="#重排规则" class="headerlink" title="重排规则"></a>重排规则</h2><blockquote>
<p><a href="https://blog.csdn.net/pzxwhc/article/details/48984209" target="_blank" rel="noopener">详细参考传送门</a></p>
</blockquote>
<ul>
<li><p>as if serial语义</p>
<p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会改变。</p>
</li>
<li><p>happen-before原则</p>
<p>一个线程中的每一个操作happens-before于该线程的任意后续操作，这里的happens-before并不是前一个操作必须早于后一个操作， 而是<strong>前一个操作必须对后一个操作可见，否则不能重排序。</strong></p>
<ul>
<li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p>
<p>主要含义是：在一个线程内不管指令怎么重排序，程序运行的结果都不会发生改变。和as-if-serial 比较像。</p>
</li>
<li><p>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>主要含义是：同一个锁的解锁一定发生在加锁之后</p>
</li>
<li><p>管程锁定规则：一个线程获取到锁后，它能看到前一个获取到锁的线程所有的操作结果。<br>主要含义是：无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p>
</li>
<li><p>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>主要含义是：如果一个线程先去写一个volatile变量，然后另一个线程又去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p>
</li>
<li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。<br>+<br>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。<br>主要含义是：线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p>
</li>
<li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>主要含义是：如果在线程A执行过程中调用了线程B的join方法，那么当B执行完成后，在线程B中所有操作结果对线程A可见。</p>
</li>
<li><p>线程中断规则：对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。<br>主要含义是：响应中断一定发生在发起中断之后。</p>
</li>
<li><p>对象终结规则：就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p>
</li>
</ul>
<blockquote>
<p>扩展：</p>
<p>如何解决并发情况下指令重排的问题：</p>
<p>一种是使用内存屏障（volatile），另一种使用临界区（synchronized ）。</p>
</blockquote>
</li>
</ul>
<h2 id="volatile的用法"><a href="#volatile的用法" class="headerlink" title="volatile的用法"></a><code>volatile</code>的用法</h2><ul>
<li><p>如何保障线程的可见性</p>
</li>
<li><p>解决指令重排（禁止指令重排序）</p>
<blockquote>
<p>volatile如何解决指令重排的问题：</p>
<ol>
<li>代码层级增加 volatile关键按字</li>
<li>翻译成汇编语言会有ACC_VOLATILE</li>
<li>在JVM执行时会增加内存屏障，屏障两边的指令不可重排序</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>屏障两边的指令不允许重排。</p>
<p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。</p>
<blockquote>
<p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p>
<p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
</blockquote>
<h2 id="内存屏障的作用"><a href="#内存屏障的作用" class="headerlink" title="内存屏障的作用"></a>内存屏障的作用</h2><ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ol>
<h2 id="java中的内存屏障"><a href="#java中的内存屏障" class="headerlink" title="java中的内存屏障"></a>java中的内存屏障</h2><p>java的内存屏障通常所谓的四种即<code>LoadLoad</code>,<code>StoreStore</code>,<code>LoadStore</code>,<code>StoreLoad</code>实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p>
<ul>
<li><p>LoadLoad屏障</p>
<p>对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p>StoreStore屏障</p>
<p>对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
</li>
<li><p>LoadStore屏障</p>
<p>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
</li>
<li><p>StoreLoad屏障</p>
<p>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>
</li>
</ul>
<h2 id="volatile中的内存屏障"><a href="#volatile中的内存屏障" class="headerlink" title="volatile中的内存屏障"></a>volatile中的内存屏障</h2><p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
<blockquote>
<p>扩展：</p>
<p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p>
</blockquote>
<h2 id="线程栈有可能发生哪些异常（内存溢出）"><a href="#线程栈有可能发生哪些异常（内存溢出）" class="headerlink" title="线程栈有可能发生哪些异常（内存溢出）"></a>线程栈有可能发生哪些异常（内存溢出）</h2><p>​    可参考 <a href="[https://brilliant-liu.github.io/2020/07/16/%E4%BA%86%E8%A7%A3JVM/#JVM](https://brilliant-liu.github.io/2020/07/16/了解JVM/#JVM)">brilliant-liu JVM</a></p>
<ol>
<li><p>什么是虚拟机栈</p>
<p>虚拟机栈是用于描述java方法执行的内存模型。</p>
<p>每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/07/12/JO1X6kUBPLNIKuZ.png"  alt="image.png"></p>
</li>
</ol>
<blockquote>
<p>虚拟机栈的特点：</p>
<p>线程隔离的，每个线程都有自己独立的虚拟机栈。</p>
</blockquote>
<ol start="2">
<li><p>线程栈可能发生的异常</p>
<ul>
<li><p>StackOverflowError</p>
<p>若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</p>
<p>JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽。</p>
</li>
<li><p>OutOfMemoryError</p>
<p>OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>扩展：</p>
<ol>
<li><p>在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。</p>
</li>
<li><p>内存溢出分为两大类：OutOfMemoryError和StackOverflowError</p>
</li>
<li><p>内存泄漏：指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>
</li>
<li><p>内存溢出 out of memory :</p>
<p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>
</li>
<li><p>内存溢出的解决方案：</p>
<ul>
<li>线上操作方面<ul>
<li>通过查看dump文件或者jconsole等工具，定位内存占用的问题。</li>
</ul>
</li>
<li>代码层面<ul>
<li>修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</li>
<li>避免一次性读取或者加载过大的数据及文件（如数据库一次读取过多的数据等）</li>
<li>检查是否有大循环重复产生新对象实体</li>
</ul>
</li>
</ul>
</li>
<li><p>导致内存泄露的常见原因：</p>
<ul>
<li><p>长生命周期的对象持有短生命周期对象的引用，就很可能发生内存泄露。</p>
</li>
<li><p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，</p>
<p>这个内部类对象被长期引用了，即使那个外部类实例对象不再被使</p>
<p>用，但由于内部类持久外部类的实例对象，这个外部类对象将不会</p>
<p>被垃圾回收，这也会造成内存泄露。</p>
</li>
<li><p>当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否正也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露</p>
</li>
</ul>
</li>
<li><p><strong>JVM内存区域程序计数器不会发生内存溢出。</strong></p>
</li>
<li><p>内存内存区域的划分图（来自互联网）</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/07/12/l8iqrZAstVzMP2p.png"  alt="image.png"></p>
</li>
<li><p>oom如何排查</p>
</li>
</ol>
</blockquote>
<p>详情可以参考我的博客<a href="[https://brilliant-liu.github.io/2020/07/16/%E4%BA%86%E8%A7%A3JVM/](https://brilliant-liu.github.io/2020/07/16/了解JVM/)">JVM</a></p>
<h2 id="oom排查"><a href="#oom排查" class="headerlink" title="oom排查"></a>oom排查</h2><ul>
<li><p>开启OOM快照</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError</code>（开启堆快照）<br><code>-XX:HeapDumpPath=C:/Users/BUFORD/Desktop/111/m.hprof</code>（保存文件到哪个目录）</p>
<p>只要你加入了这两个参数，在JVM OOM崩溃的时候，无论你是立马主动收到一个报警，还是被动让客服通知了你，立马就可以去找OOM时候的内存快照了。</p>
</li>
<li><p>查看dump文件</p>
<ul>
<li><p><code>Heap dump</code></p>
<p><code>Heap dump</code>文件是一个二进制文件，它保存了某一时刻JVM堆中对象使用情况。<code>Heap Dump</code>文件是指定时刻的Java堆栈的快照，是一种镜像文件。查看JVM内存分配以及使用情况</p>
<p>使用：使用 jmap 命令生成 dump 文件(*.hprof)使用使用<code>jprofiler</code>打开生成的文件，即可查看具体的信息。</p>
<blockquote>
<p><code>jmap -dump:live,format=b,file=c:\dump\heap.hprof &lt;pid&gt;</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>Thread dump</code></p>
<p>其能保存cpu和线程的执行情况。能用来查找内存泄露，常见的是程序里load大量的数据到缓存；发现死锁线程；</p>
<p>使用：</p>
<blockquote>
<p><code>jstack -l  pid  &gt;  /home/test/jstack.txt</code></p>
</blockquote>
</li>
</ul>
<ul>
<li><p>通过jdk自带的jconsole来看</p>
<p>JConsole是一个内置Java性能分析器，可以从命令行或在GUI shell中运行。您可以轻松地使用JConsole（或者，它更高端的“近亲” VisualVM）来监控Java应用程序性能和跟踪Java中的代码。</p>
</li>
</ul>
<h1 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h1><p>官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。下面是官方测试的数据图，展示的QPS和连接数之间的关系（图片来源互联网，仅供参考）。</p>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/2018030715491722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg3MDUxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt="QPS-连接数"></p>
<p>redis快的原因总结：</p>
<ul>
<li><p>完全基于内存。绝大部分请求是纯粹的内存操作，非常快速。</p>
</li>
<li><p>内存结构简单。Redis是KV结构的内存数据库，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
</li>
<li><p>采用单线程。避免了不必要的上下文切换和竞争条件，避免了因进程切换导致CPU的消耗以及避免了各种锁的问题。</p>
<blockquote>
<p>Redis采用单进程的原因：</p>
<p>因为redis是基于内存的数据库，单线程已经够用了，CPU 不是 redis 的瓶颈。Redis 的瓶颈最有可能是机器内存 或者网络带宽</p>
</blockquote>
</li>
<li><p>多路 I/O 复用模型。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）</p>
<blockquote>
<p>什么是多路复用：</p>
</blockquote>
</li>
</ul>
<p>redis String类型的存储结构：            </p>
<p>Zset的底层存储结构：<a href="https://www.cnblogs.com/wuyizuokan/p/11108417.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyizuokan/p/11108417.html</a></p>
<p><a href="https://www.jianshu.com/p/160fb0f73841" target="_blank" rel="noopener">https://www.jianshu.com/p/160fb0f73841</a></p>
<h1 id="缓存穿透、缓存击穿、缓存雪崩、缓存预热"><a href="#缓存穿透、缓存击穿、缓存雪崩、缓存预热" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩、缓存预热"></a>缓存穿透、缓存击穿、缓存雪崩、缓存预热</h1><ul>
<li><p>缓存预热：服务器启动后迅速宕机，因为请求数据量交高，主从直接数据吞吐量较大，数据同步操作频度交高。</p>
<blockquote>
<p>解决措施：</p>
<ol>
<li>可以使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用CDN(内容分发网络)，效果会更好。</li>
</ol>
</blockquote>
</li>
<li><p>缓存雪崩：瞬间过期数据量太大，导致数据服务器压力过大从而引起一系列数据库服务器、redis集群崩溃的问题。</p>
<blockquote>
<p>解决措施：</p>
<ol>
<li>将过期策略LRU与LFU的切换</li>
<li>数据有效期的调整</li>
<li>构建多级缓存架构，nginx缓存+redis缓存+ehcache缓存</li>
<li>优化Mysql耗时</li>
<li>进行灾难预警监控。</li>
<li>限流，降级</li>
</ol>
</blockquote>
</li>
<li><p>缓存击穿:  redis中某个key过期，该key的访问量巨大，多个数据请求redis后，均为命中，造成短时间内发起对数据库的同一数据的请求。</p>
<blockquote>
<p>解决措施：</p>
<ol>
<li>调整key的过期时间</li>
<li>设置二级缓存，保障不会同时被淘汰。</li>
<li>加锁，使用分布式锁，防止被击穿。</li>
</ol>
</blockquote>
</li>
<li><p>缓存穿透: 系统平稳运行中，redis服务器命中率随时间逐步降低，redis内存平稳，内存无压力，但是cup占用激增，数据库服务器压力激增，导致数据库崩溃。<br>可能导致的原因：redis中大面积出现未命中，查询大量不存在的key，出现非正常访问URL。例如黑客攻击。</p>
<blockquote>
<p>解决措施：</p>
<ol>
<li>白名单策略</li>
<li>实施监控，对访问进行黑名单防空。</li>
<li>key加密，如果key不满足规则，驳回数据请求访问。</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><h2 id="DCL单例（Double-Check-Lock）"><a href="#DCL单例（Double-Check-Lock）" class="headerlink" title="DCL单例（Double Check Lock）"></a>DCL单例（Double Check Lock）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： 双重锁定检查（DCL,Double Check Lock）单例模式写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DclInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DclInstance instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DclInstance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DclInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DclInstance<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( <span class="keyword">null</span> == instance )&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DclInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： 饿汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungerInstance hungerInstance = <span class="keyword">new</span> HungerInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungerInstance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  HungerInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungerInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>： 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInstance LazyInstance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInstance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == LazyInstance)&#123;</span><br><span class="line">            LazyInstance = <span class="keyword">new</span> LazyInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LazyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="系统底层如何实现数据一致性"><a href="#系统底层如何实现数据一致性" class="headerlink" title="系统底层如何实现数据一致性"></a>系统底层如何实现数据一致性</h1><ul>
<li><p>MESI(缓存一致性协议)如果能过解决，就使用MESI</p>
</li>
<li><p>如果不能使用MESI，就锁总线（效率较低）</p>
</li>
</ul>
<h2 id="缓存一致性协议："><a href="#缓存一致性协议：" class="headerlink" title="缓存一致性协议："></a>缓存一致性协议：</h2><p>由于内存的运行速度和CPU的运行速度相差太多，所以现代计算机CPU都不是直接操作内存，而是直接操作寄存器和高速缓存，如果只有一个CPU这个事情就很简单，但是如果计算机中有多个核，那每个CPU都从主内存中读取了同一个变量，如何保证缓存的一致性，就变得非常麻烦，现在常用的解决办法有两种。</p>
<p><strong>总线锁定</strong>：当某个CPU需要修改某个数据的时候，通过锁住内存总线，使得别的CPU无法访问内存中的数据，从而保证缓存的一致性,但这种实现方式会导致CPU执行效率降低，现在很少被使用。</p>
<p><strong>缓存锁</strong>：当一个CPU要修改缓存中的变量时，会对缓存加锁，同时会通过总线通知别的CPU，让他们的变量副本失效，这样同样可以保证一次只有一个CPU修改变量的值，从而保证缓存一致性。</p>
<p>以上两种方法的实质作用都是为了防止读取到脏数据和更新的结果无效。</p>
<p>MESI:</p>
<p>MESI协议是基于Invalidate的高速缓存一致性协议，并且是支持回写高速缓存的最常用协议之一。</p>
<p>MESI中每个缓存行都有四个状态，MESI是四个单词的首字母缩写，Modified修改,Exclusive独占,Shared共享,Invalid无效，下面就简要介绍一下这四种状态。</p>
<p>M：表示当前CPU的高速缓存中的变量副本是独占的，而且和主存中的变量值不一致，而且别的CPU的flag不可能是这个状态。如果别的CPU想要读取变量的值，不能直接读主内存中的值，而是需要将处于M状态的变量刷新回主内存才可以。</p>
<p>E：表示当前CPU的高速缓存中的变量副本是独占的，别的CPU高速缓存中该变量的副本不能处于该状态，但是，处于E状态的高速缓存变量的值和主内存中的变量值是一致的。</p>
<p>S：处于S状态表示CPU中的变量副本和主存中数据一致，而且多个CPU都可以处于S状态，举例，当多个CPU读取主内存的值的时候高速缓存的flag就处于S状态。</p>
<p>I：表示当前CPU的高速缓存的变量副本处于不合法状态，不可以直接使用，需要从主内存重新读取，flag的初始状态就是I。</p>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><blockquote>
<p>本质上来说：进程时资源分配的基本单位，线程时执行的基本单位</p>
<p>超线程： 一个ALU(逻辑计算单元)对应多个PC、registers,也就是所谓的四核八线程。</p>
</blockquote>
<h1 id="消息中间件MQ的对比"><a href="#消息中间件MQ的对比" class="headerlink" title="消息中间件MQ的对比"></a>消息中间件MQ的对比</h1><table>
<thead>
<tr>
<th>特性</th>
<th>RabbitMQ</th>
<th>kafka</th>
<th>ActiveMQ</th>
<th>RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>开发语音</td>
<td>erlang</td>
<td>scala</td>
<td>java</td>
<td>java</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级</td>
<td>10万级</td>
<td>万级</td>
<td>10万级</td>
</tr>
<tr>
<td>时效性</td>
<td>us级</td>
<td>ms级以内</td>
<td>ms级</td>
<td>ms级</td>
</tr>
<tr>
<td>可用性</td>
<td>高可用主从架构</td>
<td>非常高（分布式架构）</td>
<td>高主从架构</td>
<td>非常高（分布式架构）</td>
</tr>
<tr>
<td>功能特性</td>
<td>性能极其好，延时很低；提供开源的管理界面；能保证消息队列的高可用</td>
<td>仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展，kafka可能存在这重复消费。适合大数据实时计算和数据收集。</td>
<td>偶尔会有较低概率丢失消息</td>
<td>MQ功能完备，扩展性能好</td>
</tr>
</tbody></table>
<p>关于RabbitMQ相关的基础知识，参考我的博客笔记：<a href="[https://brilliant-liu.github.io/2020/07/11/%E5%85%B3%E4%BA%8ERabbitMQ/#%E4%BB%80%E4%B9%88%E6%98%AFMQ](https://brilliant-liu.github.io/2020/07/11/关于RabbitMQ/#什么是MQ)">brilliant-liu的RabbitMQ</a></p>
<blockquote>
<p>扩展：</p>
<ol>
<li><p>如何保证mq消费者的业务逻辑幂等</p>
<ul>
<li>在消费消息之前进行业务状态判断，对已经处理过的业务消息不再处理。</li>
<li>定义一个缓存，对已经消费成功过的消息id进行记录，重复消息过来时不在继续消费。</li>
<li>唯一ID + 指纹码机制，利用数据库主键去重</li>
<li>利用redis的原子性去实现。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>RabbitMQ的优点</p>
<ul>
<li>开源、性能优秀、稳定性好</li>
<li>能提供可靠的消息投递模式（confirm）,返回模式（return）</li>
<li>能与springAMQP完美整合，aip丰富</li>
<li>集群模式丰富，表达式配置，HA模式，镜像队列模型</li>
<li>保证数据不丢失的前提下做到高可靠性，可用性。</li>
</ul>
</li>
</ol>
</blockquote>
<h1 id="如何保障redis的高可用"><a href="#如何保障redis的高可用" class="headerlink" title="如何保障redis的高可用"></a>如何保障redis的高可用</h1><p>具体的redis基础信息，可以参考我的博客：<a href="[https://brilliant-liu.github.io/2020/05/01/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82redis/#%E4%BB%80%E4%B9%88%E6%98%AFredis](https://brilliant-liu.github.io/2020/05/01/一文看懂redis/#什么是redis)">看懂redis</a></p>
<ul>
<li><p>搭建主从架构 + 哨兵模式</p>
<blockquote>
<p>哨兵：是一个分布式系统，用于对主从结构中的每台服务器进行监控，每当出现故障，通过投票的机制选择新的master并将所有的slave连接到新的master</p>
<p>哨兵也是一台redis服务器，只是不提供服务。通知器配置的数量为单数。</p>
</blockquote>
</li>
</ul>
<p>如果主节点挂掉，如何处理：</p>
<p>对于非哨兵模式的架构</p>
<ol>
<li><p>登录从节点主机，执行<code>SLAVEOF NO ONE</code>断开主从关系并且提升为主库继续服务；</p>
</li>
<li><p>登录原主库，重启，将其作为从节点，等待数据同步。</p>
</li>
</ol>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><p>详情可以参考我的博客：<a href="[https://brilliant-liu.github.io/2020/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%9F%B3ZK/](https://brilliant-liu.github.io/2020/07/25/分布式基石ZK/)">分布式基石ZK</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">brilliant-liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://brilliant-liu.github.io/2020/07/08/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">https://brilliant-liu.github.io/2020/07/08/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://brilliant-liu.github.io" target="_blank">brilliant-liu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-94a00bfec307801902f81d81140a1c8a_1200x500.jpg&amp;refer=http%3A%2F%2Fpic2.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/11/%E7%9C%8B%E6%87%82%E9%94%81%EF%BC%81%EF%BC%81%EF%BC%81/"><img class="prev_cover lazyload" data-src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2560283127,3256626002&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">看懂锁！！！</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/05/docker%E5%AE%89%E8%A3%85ElasticSearch/"><img class="next_cover lazyload" data-src="http://img5.imgtn.bdimg.com/it/u=2677121778,4211715873&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker安装ElasticSearch</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495300491,4227073467&amp;fm=26&amp;gp=0.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By brilliant-liu</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">让我们从现在开始，把每一刻都过的值得。</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>